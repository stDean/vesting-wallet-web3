// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import {Test, console} from "forge-std/Test.sol";
import {StdInvariant} from "forge-std/StdInvariant.sol";
import {VestingWalletHandler} from "test/fuzz/VestingWalletHandler.t.sol";
import {VestingWallet} from "src/VestingWallet.sol";
import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";
import {MockToken} from "src/MockToken.sol";
import {DeployVestingWallet} from "script/DeployVestingWallet.s.sol";

/**
 * @title VestingWalletInvariantTest
 * @author Dean
 * @notice Invariant test suite for VestingWallet contract
 * @dev This contract tests fundamental properties and invariants of the VestingWallet contract
 * using Foundry's invariant testing framework. It ensures that critical system properties
 * remain true under all conditions and random inputs generated by the handler contract.
 *
 * @custom:invariant Total vested amount consistency
 * @custom:invariant Total released amount consistency
 * @custom:invariant Contract token balance accuracy
 * @custom:invariant Vested amount bounds validation
 * @custom:invariant Released amount bounds validation
 * @custom:invariant Releasable amount calculation accuracy
 * @custom:invariant No duplicate beneficiaries
 */
contract VestingWalletInvariantTest is StdInvariant, Test {
    DeployVestingWallet deployer;
    VestingWallet public vestingWallet;
    MockToken public token;
    VestingWalletHandler handler;
    address owner;

    /**
     * @notice Sets up the invariant test environment
     * @dev Deploys contracts, initializes the handler, and configures the invariant testing target
     * This function runs before each invariant test to ensure a clean state
     */
    function setUp() external {
        deployer = new DeployVestingWallet();
        (vestingWallet, token) = deployer.run();
        owner = vestingWallet.getContractOwner();

        // Mint tokens to owner
        token.mint(owner, 1000 ether);

        // Initialize the handler contract for invariant testing
        handler = new VestingWalletHandler(vestingWallet, token, owner);

        // Target the handler for invariant testing - Foundry will call random functions on it
        targetContract(address(handler));

        // Exclude owner from fuzz tests to prevent interference with access control
        excludeSender(owner);
    }

    /**
     * @notice Invariant: Total vested should always equal the sum of all vesting schedule amounts
     * @dev Ensures that the handler's tracked vested amount matches the actual contract state
     * @custom:invariant The sum of all vesting schedule amounts should equal the handler's totalVested
     */
    function invariant_totalVested() public view {
        uint256 totalVestedInContract;

        for (uint256 i = 0; i < handler.getBeneficiaryCount(); i++) {
            address beneficiary = handler.getBeneficiary(i);
            (uint256 totalAmount,,,) = vestingWallet.s_vestingSchedules(beneficiary);
            totalVestedInContract += totalAmount;
        }

        assertEq(totalVestedInContract, handler.totalVested());
    }

    /**
     * @notice Invariant: Total released should match the sum of all released amounts
     * @dev Ensures that the handler's tracked released amount matches the actual contract state
     * @custom:invariant The sum of all released amounts should equal the handler's totalReleased
     */
    function invariant_totalReleased() public view {
        uint256 totalReleasedInContract;

        for (uint256 i = 0; i < handler.getBeneficiaryCount(); i++) {
            address beneficiary = handler.getBeneficiary(i);
            (,,, uint256 releasedAmount) = vestingWallet.s_vestingSchedules(beneficiary);
            totalReleasedInContract += releasedAmount;
        }

        assertEq(totalReleasedInContract, handler.totalReleased());
    }

    /**
     * @notice Invariant: Contract token balance should equal total vested minus total released
     * @dev Ensures the contract's token balance is always consistent with the vesting state
     * @custom:invariant Contract token balance should equal totalVested - totalReleased
     */
    function invariant_contractBalance() public view {
        uint256 expectedBalance = handler.totalVested() - handler.totalReleased();
        assertEq(token.balanceOf(address(vestingWallet)), expectedBalance);
    }

    /**
     * @notice Invariant: Vested amount should never exceed total amount for any beneficiary
     * @dev Ensures the vested amount calculation never exceeds the total allocated amount
     * @custom:invariant vestedAmount should always be <= totalAmount for each beneficiary
     */
    function invariant_vestedAmount() public view {
        for (uint256 i = 0; i < handler.getBeneficiaryCount(); i++) {
            address beneficiary = handler.getBeneficiary(i);
            (uint256 totalAmount,,,) = vestingWallet.s_vestingSchedules(beneficiary);
            uint256 vestedAmount = vestingWallet.vestedAmount(beneficiary);

            assertLe(vestedAmount, totalAmount);
        }
    }

    /**
     * @notice Invariant: Released amount should never exceed vested amount for any beneficiary
     * @dev Ensures that released tokens never exceed the amount that has actually vested
     * @custom:invariant releasedAmount should always be <= vestedAmount for each beneficiary
     */
    function invariant_releasedAmount() public view {
        for (uint256 i = 0; i < handler.getBeneficiaryCount(); i++) {
            address beneficiary = handler.getBeneficiary(i);
            (,,, uint256 releasedAmount) = vestingWallet.s_vestingSchedules(beneficiary);
            uint256 vestedAmount = vestingWallet.vestedAmount(beneficiary);

            assertLe(releasedAmount, vestedAmount);
        }
    }

    /**
     * @notice Invariant: Releasable amount should always equal vested minus released
     * @dev Ensures the releasable amount calculation is mathematically correct
     * @custom:invariant releasableAmount should always equal vestedAmount - releasedAmount
     */
    function invariant_releasableAmount() public view {
        for (uint256 i = 0; i < handler.getBeneficiaryCount(); i++) {
            address beneficiary = handler.getBeneficiary(i);
            uint256 releasableAmount = vestingWallet.releasableAmount(beneficiary);
            uint256 vestedAmount = vestingWallet.vestedAmount(beneficiary);
            (,,, uint256 releasedAmount) = vestingWallet.s_vestingSchedules(beneficiary);

            assertEq(releasableAmount, vestedAmount - releasedAmount);
        }
    }

    /**
     * @notice Invariant: No duplicate beneficiaries
     * @dev Ensures the handler doesn't create duplicate vesting schedules for the same beneficiary
     * @custom:invariant No beneficiary should appear more than once in the handler's list
     */
    function invariant_noDuplicateBeneficiaries() public view {
        for (uint256 i = 0; i < handler.getBeneficiaryCount(); i++) {
            address beneficiary1 = handler.getBeneficiary(i);

            for (uint256 j = i + 1; j < handler.getBeneficiaryCount(); j++) {
                address beneficiary2 = handler.getBeneficiary(j);
                assertTrue(beneficiary1 != beneficiary2, "Duplicate beneficiary found");
            }
        }
    }
}
